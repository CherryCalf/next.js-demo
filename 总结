1.线程原子性：本身指令的非原子性；CPU的上下文切换

2.可见性问题：子线程无法访问主内存的共享变量，只能通过自身操作每次都从主内存中获取

3.有序性问题：各种情况导致实际运行时指令被执行的实际次序不同于源码所写的逻辑次序

4. ArrayList, Vector哪个是线程安全的，哪个是线程不安全的，其中线程安全是如何实现的？
  Vector线程安全，Vector所有方法都被synchronized关键字修饰，但是每次调用都会触发锁机制，增加了额外开销，牺牲了性能

5. ConcurrentHashMap, HashMap, HashTable哪个是线程安全的，哪个是线程不安全的，线程安全是如何实现的？是实际开发中需要用到线程安全的Map时，首选哪一个，为什么？
  线程安全ConcurrentHashMap>HashTable> HashMap
HashTable在其方法上使用了synchronized关键字，ConcurrentHashMap使用了CAS算法+Synchronizer策略从而提高并发性能
  实际开发中首选ConcurrentHashMap，它提供了良好的扩展性和吞吐量表现，适应多核处理器下的高强度负载要求，并且相较于传统HashTable，采用更加灵活的CAS算法+Synchronizer策略使整体效率得到极大提升

6. 在分布式部署的情况下，存储数据时需要考虑什么？
  数据一致性，IO读写优化，资源分配合理，高效同步策略

7.同步
任务按预定顺序依次执行
  优点：有序性，简单直观
  缺点：阻塞，性能问题，资源利用不高




8.异步
  任务同时执行
  优点：非阻塞，资源利用率高，灵活
  缺点：复杂性提高，无序性

9. 用代码实现死锁，并说明被锁住线程的当前状态？
 
两个线程分别持有一个锁，并试图获得对方持有的另一把锁，由于双方都在等待对方释放自己的锁，因此进入了一个无法继续执行的状态

10.悲观锁
总是假设最坏的情况，认为共享资源每次访问的时候就会出现问题，所以每次获取资源操作的时候都会上锁，这样其他资源想拿到这个资源就会阻塞，直到锁被上一个持有者释放
 

11.乐观锁
  总是假设最好的情况，认为资源共享每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源是否被其他线程修改了

12.CAS算法
  CAS的思想很简单，就是用一个预期值和要更新的值进行比较，两值相等时才会进行更新，CAS是一个原子操作，底层依赖于一条CAS的原子指令
  缺点：只比较预期值与实际值，期间发生变化无法判断

13.Executors类
  线程池：当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务
  当同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时会触发拒绝策略



14.创建线程池
 

15.为什么不推荐使用通过Executors类的静态方法创建线程池?
  潜在的资源耗尽风险：默认无界队列，可能导致任务堆积过多而占用大量内存
缺乏灵活性：封装线程池细节，隐藏了重要参数的设置
固定的线程池行为：默认实现的特性可能不适合特定场景
未提供合理的超时机制：长期空闲或没有合理的时间限制会浪费系统资源

16.实现懒汉单例类
  懒汉单例类是一种延迟加载方式，在第一次调用getInstance时才创建实例，可以节省资源，只有当真正需要使用对象的时候才会初始化它
   









17.实现一个建议的生产者消费者模型
18.Stream API
  源码在java.util.stream，允许以声明式的方式处理数据集合，Stream不存储数据，但它可以检索和逻辑处理集合数据，包括筛选，排序，统计，计数等，可以理解为sql，一般与Lambda配合使用

19.Optional Class
  用于表示可能存在或不存在的值，它旨在帮助开发者更优雅的处理null

20.Date-Time API
  Java8之前的缺点：非线程安全，时区处理麻烦，各种格式化和时间计算繁琐，同时包含日期和时间，还有一个java.sql.Date容易混淆

21.StringBuilder和StringBuffer的使用？
  StringBuffer中大多数方法被synchronized关键字修饰，使得它在线程并发环境中是安全的，但会带来额外的开销，从而降低运行效率。
  StringBuilder未采用任何同步措施，因为线程不安全，但在单线程环境下有更高的性能

22.分别用Calender和LocalDate实现获取2025年最后一个周日
 
 

23. 用Stream API 和Lambda 表达式实现，将一个用户集合按照年龄分组，得到一个Map，key为年龄，value为该年龄的用户集合
 
 

24.注解
  @Component 将类标识为普通的组件
  @Service 将类标识为服务层的服务
  @Repository 将类标识为数据层的数据仓库
  @Controller 将类标识为Web层的Web控制器
  @Autowired 根据类型注入依赖，可用以构造方法，Setter方法或者成员变量
  @Resource JSR-250规范提供的注解，根据名称注入依赖
  @Inject JSR-250规范提供的注解，同@Autowired
  @Configuration 表示类是一个Java配置类
  @ComponentScan 指定了扫描的包名
  @Bean 修饰的方法返回的对象保存在Spring容器中
  @Lazy 说明这个Bean是延迟加载的
  @Scope 指定bean范围
  @EventListener 监听事件
  @PointCut AOP切点
  @Aspect 定义一个切面
  @Before 声明前置通知
  @AferReturning 声明后置通知
  @AfterThrowing 拦截方法抛出的异常
  @Around 声明环绕通知

25.Bean的生命周期
  创建对象->注入依赖->创建后回调->正常使用->销毁前回调->销毁对象

26.AOP
  切面：按关注点进行模块分解时，切面关注点就表示一个切面
  连接点：程序执行的某一刻，在这个点可以添加额外的动作
  通知：切面在特定连接点上执行的动作
  切入点：切入点是用来描述连接点的，它解决了当前代码与连接点是否匹配
	






27. 使用需要创建一个任务列表页面，一个input输入框，右边有一个添加任务的按钮，每当在input输入框中输入一个内容，点击添加任务按钮之后，下方的任务列表就会根据输入的内容多出一条任务，这条任务的右侧有一个delete删除按钮，点击之后会删除这条添加的任务。
28.构建state原则
  合并失联的state，避免互相矛盾的state，避免冗余的state，避免重复的state，避免深度嵌套的state
  多个state总是一起更新，考虑合并成一个；慎重考虑state结构，类型，避免陷入麻烦；避免冗余和重复的state；如果深度嵌套state更新很麻烦，尝试先将其扁平化

29.状态提升
为了让两个组件的状态始终同步更改。要实现这一点，可以将相关 state 从这两个组件上移除，并把 state 放到它们的公共父级，再通过 props 将 state 传递给这两个组件。
  把子组件的状态移动到父组件当中
  父组件把状态当作子组件的props向下传递
  子组件通过回调函数更改父组件状态

30.共享组件状态
  状态提升可以理解为把子组件由state驱动变成了由prop驱动，是一个把子组件从受控组件变成不受控组件的过程
  由prop驱动称之为受控组件
  由state驱动称之为不受控组件
  	

















31. 现在有两个独立的输入框。为了让它们保持同步：即编辑一个输入框时，另一个输入框也会更新相同的文本，反之亦然。请尝试动手实现以下

